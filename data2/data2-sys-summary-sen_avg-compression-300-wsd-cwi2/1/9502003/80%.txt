 Any subset of this set of possible values can be encoded as one Prolog term Cyclic terms arise naturally in NLP through unification of non-cyclic terms, e The compilation of sorted feature terms into a Prolog term representation is based on the following principles, which are explained in more detail in , , ,  The Prolog representation of a sort is an instance of the Prolog representation of its supersorts Features are represented by arguments We illustrate these principles for compiling sorted feature terms into Prolog terms with an example from HPSG $sign(Var,LexPhras,Phon,Synsem,Qstore,Retriev) The following declaration introduces two sort hierarchy dimensions for subsorts of phrasal, and one new feature ProFIT has been implemented in Quintus and Sicstus Prolog, and should run with subset Prolog that conforms to or extends the proposed ISO Prolog standard A program file (a Prolog program) that contains the clauses, with all ProFIT terms compiled into their Prolog term representation graphemic form and logical form) are represented as normal Prolog terms For the development of ProFIT programs and grammars, it is necessary to give input and output and debugging information in ProFIT terms, since the Prolog term representation is not very readable ProFIT provides a user interface which accepts queries containing ProFIT terms, and translates them into Prolog queries, converts the solutions to the Prolog query back into ProFIT terms before printing them out, prints out debugging information as ProFIT terms In order to give a rough idea of the efficiency gains of a compilation into Prolog terms instead of using a feature term unification algorithm implemented on top of Prolog, we have compared the runtimes with ALE and the Eisele-Drre algorithm for unsorted feature unification for the following tasks: (i) unification of (unsorted) feature structures, (ii) unification of inconsistent feature structures (unification failure (iii) unification of sorts, (iv) lookup of one of 10000 feature structures (euni-sbde, directory: pub/profit  It is very likely that the most efficient commercial Prolog systems, which provide a basis for the implementation of NLP systems, will conform to the proposed ISO standard It has been noted that first-order Prolog terms provide the equivalent expressive power as sorted feature terms  ProFIT is not a grammar formalism, but rather aims to extend current and future formalisms and processing models in the logic grammar tradition with the expressive power of sorted feature terms For example, Carpenter's typed feature structures can easily be represented as Prolog terms, if the restriction is given up that the sort hierarchy be a bounded complete partial order Most of the progress in constructing efficient parsers and generators has been based on logic grammars that make use of ordinary Prolog terms Such compilation of sorted feature terms into Prolog terms has been successfully used in the Core Language Engine (CLE) and in the Advanced Linguistic Engineering Platform (ALEP  ProFIT is not a grammar formalism, but rather extends subset grammar formalism in the logic grammar tradition with the expressive power of sorted feature terms The set of ProFIT programs is a superset of Prolog programs While a Prolog program consists only of definite clauses (Prolog is an untyped language a ProFIT program consists of datatype declarations and definite clauses A ProFIT program consists of: Declarations for sorts Declarations for features Declarations for templates Declarations for finite domains Definite clauses In addition to unsorted Prolog terms, ProFIT allows sorted feature terms, for which the sorts and features must be declared in advance We provide a general tool that brings together these developments by compiling sorted feature terms into a Prolog term representation, so that techniques from logic programming and logic grammars can be used to provide efficient processing models for sorted feature grammars Unlike unsorted feature formalisms (such as PATR-II where subset feature can be added to subset structure, ProFIT follows the notion of appropriateness in Carpenter's logic of typed feature structures , and introduces features for particular sorts A feature must be introduced only at one most general sort Appropriateness is also a prerequisite for compilation of feature terms into fixed-arity Prolog terms Each feature has a sortal restriction for its value The following sections describe the ProFIT language which provides sorted feature terms for Prolog, and its implementation On the basis of the declarations, sorted feature terms can be used in definite clauses in addition to and in combination with Prolog terms A Prolog term can have a feature term as its argument, and a feature can have a Prolog term as its value As an example, semantic representations in first-order terms can be used as feature values, but do not need to be encoded as feature terms Sorted feature terms consist of a specification of the sort of the term ( or the specification of a feature value ( or a conjunction of terms (  Note that conjunction also provides the possiblity to tag a Prolog term or feature term with a variable (Var Term  Sorted feature terms have several advantages over Prolog terms as a representation langauge The following clause makes use of feature search to express the Head Feature Principle (hfp .