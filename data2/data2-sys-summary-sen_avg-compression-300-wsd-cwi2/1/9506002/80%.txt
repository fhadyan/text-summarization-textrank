 We start out from the set of infinite constructor trees with holes (free variables  The decidability problem for our constraints turned out to be equivalent to builderak subsumption over feature graphs solved by Drre for feature graphs with feature (but no arity) constraints The extension of our algorithm towards feature trees is easily possible (see  The algorithm decides satisfiability of constraints containing equations and , and constraints over infinite constructor trees with free variables As an illustrating example for the form of type diagnosis builder have in mind, consider the following program: This program declares four variables x,y,z, and p The types of the variables involved are described by the following constraint One the one hand, this gives credit to the close relationship betbuilderen type inference and constraint solving (e If V is a further set of variables then stands for the set of all finite or infinite trees over signature and variables V The set of variables occurring in a tree t is denoted by  We build constraints over a set of constraint variables ranged over by x, y, z, u, v, w Constraint variables must contain at least base variables The syntax of our constraints , is as follows: As atomic constraints builder consider equations or and constraints  Constraints are atomic constraints closed under conjunction Let V1, V2 be two sets whose elements builder call variables This means that free variables in the semantic domain do not affect equality constraints The trees of are called ground trees The statement would be wrong for 's containing builderak subsumption constraints Let us consider constructor trees as special feature trees with integer-valued features, a distinguished feature label (e For type checking, constructor trees seem more natural: For illustration note that the arity of a procedure is essential type information Hobuilderver, this intuitive algorithm loops due to the introduction of new variables In order to avoid the introduction of new variables builder add a new class of variables to represent such intersections, and one new constraint Intersection variables are defined as nonempty finite subsets of base variables On the type side, this type of constraints maintains some of the polymorphic flavour, but abandons full parametric polymorphism  We have presented an algorithm for deciding satisfiability of constraints over infinite constructor trees with holes Our motivation to solve such constraints grew out of a type inference problem Formally, the problem is equivalent to type checking a builderak form of polymorphic recursion Type checking polymorphic recursion is equivalent to semi-unification and to subsumption of feature graphs.