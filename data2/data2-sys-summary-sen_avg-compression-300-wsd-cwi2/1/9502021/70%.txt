 Unification-based grammar formalisms can be viewed as generalizations of Context-Free Grammars (CFG) where the nonterminal symbols are replaced by an infinite domain of feature structures Tree (a) shows a LIG derivation of the substring from the object  Suppose that we have the derived tree shown in Figure where the nodes at the root of the subtrees and are the so-called f-terminator and g-terminator of the tree's root, respectively At the root of the figure the feature structures and have been expanded to show the extent of the dependency in this example In this case, the value of the feature fin must be a, whereas, the feature g is not fixed Furthermore, the value of the feature g in must be b, whereas, the feature f is not fixed Note that in this tree the value of the feature g in is and the value of the feature f in is Suppose that, in addition to the tree shown in Figure the grammar generates the pair of trees shown in Figure  The context-freeness of plpatr means that given the three trees shown in Figures and the tree shown in Figure will also be generated by the grammar This gives us a means of efficiently storing the potentially unbounded feature structures associated with nodes in a derivation tree (derived feature structures  For each feature, we store in the recognition array a bounded amount of information about its value locally, together with a pointer to a further array element unifiable) with the bounded, local information correspond to different possible values for the feature For example, we can use a single entry in the recognition array to store the fact that all of the feature structures that can appear at the root of the trees in Figure derive the substring  This entry would be underspecified, for example, the value of feature would be specified to be any feature stored in the array entry for the substring whose feature fhad the value a That is, partial linearity permits feature values to be shared between daughters where they are not also shared with the mother The plpatr recognition algorithm employs a second array (called the compatibility array which encodes information about the compatibility of derived feature structures Tuples of compatible derived feature structures are stored in the compatibility array using exactly the same approach used to store feature structures in the main recognition array Although stacks of unbounded size can arise during a derivation, it is not possible for a to specify that two dependent, unbounded stacks must appear at distinct places in the derivation tree Our goal is to generalize the constraints inherent in LIG, to a formalism that manipulates feature structures rather than stacks As a guiding heuristic we will avoid formalisms that generate tree sets with an unbounded number of unbounded, dependent branches Thus, rules may mention more than one unbounded stack, but the stack associated with the mother is still associated with at most one daughter In naive implementations of unification grammar parsers, feature structures play the same role as nonterminals in standard context-free grammar parsers Productions now specify how the tree associated with the mother is related to the trees associated with the daughters Under these conditions, the tree set shown in Figure can be generated Furthermore, the need to perform non-destructive unification means that a large proportion of the processing time is spent copying feature structures z) subtrees (these subtrees must be the full binary tree  We require that subtrees of the mother that are passed to daughters that share subtrees with one another must appear as siblings in the mother's tree We refer to this formalism as Partially Linear Tree Grammars (pltg  As a further illustration of the constraints places on shared subtrees, Figure shows a local tree that could appear in a derivation tree Note that in Figure the daughter nodes labelled B and D share a common subtree and the subtrees shared between the mother and the B and D daughters appear as siblings in the tree associated with the mother Finally, we note that acyclic feature structures without re-entrancy can be viewed as trees with branches labelled by feature names and atomic values only found at leaf nodes (interior nodes being unlabelled  Having made the move from trees to feature structures, we consider the possibility of re-entrancy in plpatr Note that the feature structure at the root of a plpatr derivation tree will not involve re-entrancy In unification-based grammar, the feature structure associated with the root of the tree is often regarded as the structure that has been derived from the input (i To do this, unbounded feature information is passed up the tree in a way that violates the constraints developed in this paper Rather than giving such prominence to the root feature structure, we suggest that the entire derivation tree should be seen as the object that is derived from the input, i Because feature structures associated with all nodes in the tree are available, feature information need only be passed up the tree when it is required in order to establish dependencies within the derivation tree When this approach is taken, there may be less need for re-entrancy in the root feature structure Furthermore, re-entrancy in the form of shared feature structures within and across nodes will be found in plpatr (see for example Figure  LIG are more powerful than cfg and are known to be weakly equivalent to Tree Adjoining Grammar, Combinatory Categorial Grammar, and Head Grammar  As is the case for the tree sets of ig, LIG and Tree Adjoining Grammar, the tree sets generated by pltg have path sets that are context-free languages While the tree sets of LIG and Tree Adjoining Grammars have independent branches, pltg tree sets exhibit dependent branches, where the number of dependent branches in any tree is bounded by the grammar Note that the number of dependent branches in the tree sets of ig is not bounded by the grammar (eg they generate sets of all full binary trees  The CKY algorithm is a bottom-up recognition algorithm for cfg.