 Because traditional notions of language complexity are generally defined in terms of rewriting mechanisms, complexity of the languages licensed by these formalisms can be difficult to determine 100] But formal language theory still has much to offer to generative linguistics It follows that a set of trees is definable in iff they are Rabin recognizable Every set of trees that is accepted in this way is the projection of a local set It is easy to show that, given a recognizable set of trees, one can construct a CFG to generate the corresponding set of trees labeled with pairs as in  Language complexity provides one of the most useful measures with which to compare languages and language formalisms If one can show that the constraints defining such a set, or perhaps that any constraints in the class employed by a given formalism, can be defined within then the corresponding language or class of languages is strongly context-free Much of the value of standard language complexity classes, on the other hand, comes from results that allow one to show that a given language or class of languages is not included in a particular complexity class If one can show that a given predicate, when added to allows definition of known non-CF languages, then clearly that predicate properly extends the power of the language and cannot be definable In this way, one can show that the predicate which holds between two nodes iff the yields of the subtrees rooted at those nodes are labeled identically wrt P is not definable in , for if it were one could define the copy language  Let be the monadic second-order theory of G More importantly, characterization results for language complexity classes tend to be in terms of the structure of languages, and the structure of natural language, while hazy, is something that can be studied more or less directly In essence, the indexation is an equivalence relation, one that distinguishes unboundedly many equivalence classes among the nodes of the tree Let S2S+CI be the monadic second-order theory of this class of structures We thus establish that this account licenses a strongly context-free language In this paper we discuss a flexible and quite powerful approach to establishing language complexity results for formalisms based on systems of constraints on trees The principles we capture include basic X-bar Theory, Theta Theory, the Case Filter, Binding Theory, Control Theory and various constraints on movement, in particular the Empty Category Principle Its definition has three components Relativized Minimality theory distinguishes a number of distinct varieties of antecedent-government, one for each class of movement The idea, now, is to define chains as any set of nodes that are linearly ordered by  Thus we are able to show that the language licensed by this particular GB theory is strongly context-free The fact that we can exhibit a definition in of the class of trees licensed by a specific GB account of English provides a strong complexity result for that class of trees it is strongly context-free Our approach to chains will work for any account of language that satisfies this principle In this paper we have introduced a kind of descriptive complexity result for the strongly Context-Free Languages a language is strongly context-free iff the set of trees analyzing the syntax of its strings is definable in (modulo a projection  Using this result we have sketched a couple of language complexity results relevant to GB, namely, that free-indexation cannot, in general, be enforced by CFGs, and that a specific GB account of English licenses a strongly context-free language Extensions of our descriptive complexity result to larger language complexity classes could provide formal restrictions on the principles employed by GB theories that would be sufficient to provide non-trivial generative capacity results for those theories without losing the ability to capture the full range of human language With such extended characterizations one might establish upper bounds on the complexity of human language in general The fact that the formalization is possible, then, establishes a relatively strong language complexity result for the theory we capture We have, then, two conflicting criteria for our language In addition, it includes an arbitrary array of monadic predicate constants constants naming specific subsets of the nodes in the tree Crucially, though, this is all the language includes We use lower-case for individual variables and constants, and upper-case for set variables and predicate constants As a result, it has been difficult to establish language complexity results for GB theories, even at the level of the recursive , or context-sensitive languages That language complexity results for GB should be difficult to come by is hardly surprising If is a set of sentences in a language , we will use the notation to denote the set of trees, ie the sets of derivation trees generated by Context-Free Grammars  The proof hinges on the fact that one can translate formulae in into the language of SnS the monadic second-order theory of multiple successor functions.