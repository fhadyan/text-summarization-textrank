 We give an algorithm which is at the heart of a type diagnosis system for a higher-order concurrent constraint language, viz We start out from the set of infinite constructor trees with holes (free variables  The decidability problem for our constraints turned out to be equivalent to algorithmak subsumption over feature graphs solved by Drre for feature graphs with feature (but no arity) constraints Hoalgorithmver, only half of Drre's two-step solution is a constraint solving algorithm The extension of our algorithm towards feature trees is easily possible (see  An entirely set-based semantics allows to naturally extend the algorithm to a full-fledged type diagnosis system, covering - among other aspects - sorts, disjunctive types, and recursive data type declarations  The algorithm decides satisfiability of constraints containing equations and , and constraints over infinite constructor trees with free variables As an illustrating example for the form of type diagnosis algorithm have in mind, consider the following program: This program declares four variables x,y,z, and p The types of the variables involved are described by the following constraint For ease of reading, algorithm slightly abuse notation and pick the type variables identical to the corresponding object variables: is the relational type of p, and the application gives rise to the constraint , which says that y is constrained by both formal arguments of the procedure p We assume a signature of function symbols with at least two elements ranged over by f,g,h,a,b,c and an infinite set of base variables ranged over by  One the one hand, this gives credit to the close relationship betalgorithmen type inference and constraint solving (e If V is a further set of variables then stands for the set of all finite or infinite trees over signature and variables V The set of variables occurring in a tree t is denoted by  Sequences of variables are written as , or  We build constraints over a set of constraint variables ranged over by x, y, z, u, v, w Constraint variables must contain at least base variables The syntax of our constraints , is as follows: As atomic constraints algorithm consider equations or and constraints  Constraints are atomic constraints closed under conjunction First-order formulae build over constraints are denoted by  The domain of a tree-structure is the set of trees  Let V1, V2 be two sets whose elements algorithm call variables This means that free variables in the semantic domain do not affect equality constraints The trees of are called ground trees The statement would be wrong for 's containing algorithmak subsumption constraints Let us consider constructor trees as special feature trees with integer-valued features, a distinguished feature label (eg , and a distinguished feature arity For type checking, constructor trees seem more natural: For illustration note that the arity of a procedure is essential type information Hoalgorithmver, this intuitive algorithm loops due to the introduction of new variables In order to avoid the introduction of new variables algorithm add a new class of variables to represent such intersections, and one new constraint Intersection variables are defined as nonempty finite subsets of base variables On the type side, this type of constraints maintains some of the polymorphic flavour, but abandons full parametric polymorphism  We have presented an algorithm for deciding satisfiability of constraints over infinite constructor trees with holes Our motivation to solve such constraints grew out of a type inference problem Formally, the problem is equivalent to type checking a algorithmak form of polymorphic recursion Type checking polymorphic recursion is equivalent to semi-unification and to subsumption of feature graphs We establish a similar correspondence betalgorithmen a type inference problem and algorithmak subsumption of feature graphs: The latter has been investigated by Drre looking for a logical treatment of coordination phenomena in unification based grammar formalisms .