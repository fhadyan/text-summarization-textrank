 Categorial Grammar (CG) and in particular Lambek Categorial Grammar (LCG) have their well-known benefits for the formal treatment of natural language syntax and semantics Hence the complete sequent to solve is: Let be a shorthand for and let X stand for the sequence of primitive types Using rule only, we can obviously prove  Let and be a witnessing derivable sequent, i Now, since the counts of this sequent must be balanced, the sequence must contain for each exactly 3 bj and exactly N cj as subformulae A drawback of the pure Lambek Calculus LMBK is that it only allows for so-called `peripheral extraction i This completes the proof We have defined a variant of Lambek's original calculus of types that allows abstracted-over categories to freely permute For practical grammar engineering one can devise the motto avoid accumulation of unbounded dependencies by whatever means On the theoretical side we think that this result for SDL is also of some importance, since SDL exhibits a core of logical behaviour that any (Lambek-based) logic must have which accounts for non-peripheral extraction by some form of permutation To our knowledge the question, whether the Lambek calculus itself or its associated parsing problem are NP-hard, are still open This inflexibility of Lambek Calculus is one of the reasons why many researchers study richer systems today For instance, the recent work by Moortgat gives a systematic in-depth study of mixed Lambek systems, which integrate the systems LMBK, NL, NLP, and LP These ingredient systems are obtained by varying the Lambek calculus along two dimensions: adding the permutation rule (P) and/or dropping the assumption that the type combinator (which forms the sequences the systems talk about) is associative (N for non-associative  The present paper studies the computational complexity of a variant of the Lambek Calculus that lies between LMBK and LP, the Semidirectional Lambek Calculus SDL Stated prove-theoretically for Gentzen-style systems, this amounts to disallowing the left rule for llimp The semidirectional Lambek calculus (henceforth SDL) is a variant of J Lambek's original calculus of syntactic types We start by defining the Lambek calculus and extend it to obtain SDL Formulae (also called syntactic types are built from a set of propositional variables (or primitive types and the three binary connectives , , called product, left implication, and right implication The (usual) formal framework of these logics is a Gentzen-style sequent calculus Figure shows Lambek's original calculus LMBK In Semidirectional Lambek Calculus we add as additional connective the LP implication llimp, but equip it only with a right rule A consequence of only allowing the rule, which is easily proved by induction, is that in any derivable sequent llimp may only appear in positive polarity Hence, llimp may not occur in the (cut) formula A of a application and any subformula which occurs somewhere in the prove must also occur in the final sequent We can show Cut Elimination for this calculus by a straight-forward adaptation of the Cut elimination proof for LMBK The cut-free system enjoys, as usual for Lambek-like logics, the Subformula Property: in any proof only subformulae of the goal sequent may appear Remarkable about this fragment is that any positive occurrence of an implication must be llimp and any negative one must be / or  The language generated by a Lambek grammar is defined as the set of all strings for which there exists a sequence of types and  An SDL-grammar is defined exactly like a Lambek grammar, except that replaces  It is not immediately obvious, how the generative capacity of SDL-grammars relate to Lambek grammars or nondirectional Lambek grammars (based on calculus LP  Whereas Lambek grammars generate exactly the context-free languages (modulo the missing empty word) , the latter generate all permutation closures of context-free languages  grammar to a syntax grammar G  Since llimp does not appear in G' each SDL-proof of a lexical assignment must be also an LMBK-proof, i exactly the same strings are judged grammatical by SDL as are judged by LMBK languages, this observation extends to SDLM Moreover, some languages which are not context-free can also be generated Example We use primitive types and define the lexical map for as follows: The distinguished primitive type is x Furthermore, due to the Subformula Property we know that in a cut-free proof of , the main formula in abstractions (right rules) may only be either or , where , since all other implication types have primitive antecedents Hence, the LHS of any sequent in the proof must be a subsequence of U, with some additional b types and c types interspersed The sequent marked with is easily seen to be derivable without abstractions We have to show, when given a solution to , how to choose a type sequence and construct an SDL proof for .