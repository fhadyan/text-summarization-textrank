 Figure depicts examples of the equations corresponding to two TFSs put_arc fills this space with REF cells One of the reasons for the efficiency of our compiler is that it performs an important part of the unification during compile-time: the type unification Since type unification adds information by returning the features of the unified type, this operation builds new structures, in our design, that reflect the added knowledge Each such function receives one parameter, the address of a TFS on the heap Consider unify_type[t1,t2 addr) where addr is the address of a TFS A (of type t2) in memory The second case, in which Xipoints to an existing TFS of type t is the more interesting one An existing TFS has to be unified with a new one whose type is t In contrast to the latter, the two TFS arguments of unify are in memory, and full unification is performed One of the drawbacks of maintaining total structures is that when two TFSs are unified, the values of features that are introduced by the unified type have to be built For example, unify_type[a,b] (equation ) has to build a TFS of type bot, which is the value of the f4 feature of type c A VAR cell whose contents is a type t stands for the most general TFS of type t This function (which is automatically generated by the type hierarchy compiler) builds a TFS of the designated type on the heap, with VAR cells instead of REF cells for the features The previous section delineated a very simple abstract machine, capable of unifying two simple TFSs The abstract machine is composed of data structures and a set of instructions, augmented by a compiler from the TFS formalism to the abstract instructions Moreover, the LIFE machine is limited to term unification, whereas our machine includes a control module that enables manipulation of whole grammars The same code is generated for the queries, with additional advance instructions preceding each TFS of the query Before the first TFS, a start_rule instruction is generated A move_dot and next_item instructions are generated between two consecutive structures, and after the last one, the head, an end_rule instruction concludes the generated code (DFS  Determining the values of these parameters is program-independent: the maintenance of the chart is fixed For lack of space we don't detail the control module In addition, we described a compiler for a general TFS-based language The use of abstract machine techniques is expected to result in highly efficient processing An HPSG grammar consists of a type specification and grammar rules (including principles and lexical rules  The set of types includes both , the least type, and , the greatest one Hence, is the most general type, subsuming every other, and is the contradictory type, subsumed by every other Every partial order can be naturally extended to a bounded complete one The basic operation performed on TFSs is unification (  A program (or a grammar) contains a type specification, consisting of a type hierarchy and an appropriateness specification Each type (except and ) must be characterized by exactly one statement The type is systematically omitted from type specifications The machine's engine is designed for unifying two TFSs: a program and a query The program is compiled once to produce machine instructions The result of the unification is a new TFS, represented as a graph in the machine's memory.