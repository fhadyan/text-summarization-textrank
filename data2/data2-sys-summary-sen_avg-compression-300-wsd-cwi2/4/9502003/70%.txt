 Clauses containing disjunctive terms are compiled to several article, one for each consistent combination of disjuncts For disjunctions of atoms, there exists a Prolog term representation, which is described below Any subset of this set of possible values can be encoded as one Prolog term Adding a new feature to a sort requires one change in a declaration, whereas adding an argument to a Prolog functor requires changes (mostly insertion of anonymous variables) to every occurence of the functor Specification of the subsort relationship is more convenient than constructing Prolog terms which mirror these subsumption relationships Unlike Prolog, the concrete syntax of ProFIT allows to write down cyclic terms by making use of conjunction: X f(X  Cyclic terms arise naturally in NLP through unification of non-cyclic terms, e ProFIT supports cyclic terms by being able to print them out as solutions The compilation of sorted feature terms into a Prolog term representation is based on the following principles, which are explained in more detail in , , ,  The Prolog representation of a sort is an instance of the Prolog representation of its supersorts Features are represented by arguments We illustrate these principles for compiling sorted feature terms into Prolog terms with an example from HPSG $sign(Var,LexPhras,Phon,Synsem,Qstore,Retriev) The following declaration introduces two sort hierarchy dimensions for subsorts of phrasal, and one new feature The corresponding Prolog term representation instantiates the representation for the sort sign further, and leaves argument positions that can be instantiated further by the subsorts of phrasal, and for the newly introduced feature daughters $sign(Var, $phrasal(Phrasesort,Clausesort,Dtrs Phon, Synsem, Qstore, Retrieved) The compilation of finite domains into Prolog terms is performed by the brute-force method described in  A finite domain with n possible domain elements is represented by a Prolog term with n+1 arguments ProFIT has been implemented in Quintus and Sicstus Prolog, and should run with any Prolog that conforms to or extends the proposed ISO Prolog standard A program file (a Prolog program) that contains the article, with all ProFIT terms compiled into their Prolog term representation If the input and output of the program (the exported predicates of a module) only make use of Prolog terms, and feature terms are only used for internal purposes, then the program file is all that is needed This is for example the case with a grammar that uses feature terms for grammatical description, but whose input and output (e graphemic form and logical form) are represented as normal Prolog terms For the development of ProFIT programs and grammars, it is necessary to give input and output and debugging information in ProFIT terms, since the Prolog term representation is not very readable ProFIT provides a user interface which accepts queries containing ProFIT terms, and translates them into Prolog queries, converts the solutions to the Prolog query back into ProFIT terms before printing them out, prints out debugging information as ProFIT terms ProFIT terms can also be output in L[A]TEX format, and an interface to the graphical feature editor Fegramed is foreseen In order to give a rough idea of the efficiency gains of a compilation into Prolog terms instead of using a feature term unification algorithm implemented on top of Prolog, we have compared the runtimes with ALE and the Eisele-Drre algorithm for unsorted feature unification for the following tasks: (i) unification of (unsorted) feature structures, (ii) unification of inconsistent feature structures (unification failure (iii) unification of sorts, (iv) lookup of one of 10000 feature structures (euni-sbde, directory: pub/profit  It is very likely that the most efficient commercial Prolog systems, which provide a basis for the implementation of NLP systems, will conform to the proposed ISO standard It has been noted that first-order Prolog terms provide the equivalent expressive power as sorted feature terms  ProFIT is not a grammar formalism, but rather aims to extend current and future formalisms and processing models in the logic grammar tradition with the expressive power of sorted feature terms For example, Carpenter's typed feature structures can easily be represented as Prolog terms, if the restriction is given up that the sort hierarchy be a bounded complete partial order Most of the progress in constructing efficient parsers and generators has been based on logic grammars that make use of ordinary Prolog terms Such compilation of sorted feature terms into Prolog terms has been successfully used in the Core Language Engine (CLE) and in the Advanced Linguistic Engineering Platform (ALEP  ProFIT extends the compilation techniques of these systems through the handling of multi-dimensional inheritance , and makes them generally available for a wide range of applications by translating programs (or grammars) with sorted feature terms into Prolog programs ProFIT is not a grammar formalism, but rather extends any grammar formalism in the logic grammar tradition with the expressive power of sorted feature terms The set of ProFIT programs is a superset of Prolog programs While a Prolog program consists only of definite article (Prolog is an untyped language a ProFIT program consists of datatype declarations and definite article A ProFIT program consists of: Declarations for sorts Declarations for features Declarations for templates Declarations for finite domains Definite article In addition to unsorted Prolog terms, ProFIT allows sorted feature terms, for which the sorts and features must be declared in advance We provide a general tool that brings together these developments by compiling sorted feature terms into a Prolog term representation, so that techniques from logic programming and logic grammars can be used to provide efficient processing models for sorted feature grammars Two intensional terms are identical only if they have been unified Unlike unsorted feature formalisms (such as PATR-II where any feature can be added to any structure, ProFIT follows the notion of appropriateness in Carpenter's logic of typed feature structures , and introduces features for particular sorts For each sort, one must declare which features are introduced by it A feature must be introduced only at one most general sort Appropriateness is also a prerequisite for compilation of feature terms into fixed-arity Prolog terms Each feature has a sortal restriction for its value The syntax of feature declarations is given in (  The following sections describe the ProFIT language which provides sorted feature terms for Prolog, and its implementation The sort binary tree introduces the feature label and its subsort adds the features left_daughter and right_daughter If a sort has subsorts and introduces features, these are combined in one declaration On the basis of the declarations, sorted feature terms can be used in definite article in addition to and in combination with Prolog terms A Prolog term can have a feature term as its argument, and a feature can have a Prolog term as its value As an example, semantic representations in first-order terms can be used as feature values, but do not need to be encoded as feature terms Sorted feature terms consist of a specification of the sort of the term ( or the specification of a feature value ( or a conjunction of terms (  A complete BNF of all ProFIT terms is given in the appendix Note that conjunction also provides the possiblity to tag a Prolog term or feature term with a variable (Var Term  Such a change of the feature geometry makes it necessary to change the path in all references to a feature Sorted feature terms have several advantages over Prolog terms as a representation langauge The following clause makes use of feature search to express the Head Feature Principle (hfp  first First|Rest First Disjunction in the general case cannot be encoded in a Prolog term representation.