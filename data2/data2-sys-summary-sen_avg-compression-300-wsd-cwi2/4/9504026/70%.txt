 Note that we allow the input to be a full FSA (possibly including cycles, etc since some of the above-mentioned techniques indeed result in cycles The resulting DCG, FSA pair for the example PCP is given in figure : The question whether the intersection of a FSA and an off-line parsable DCG is empty is undecidable Suppose the problem was decidable The PCP problem however is known to be undecidable Hence the intersection question is undecidable too Whereas an ordinary word-graph always defines a finite language, a FSA of course can easily define an infinite number of sentences Rather than assuming the input for parsing is a FSA in its full generality, we might assume that the input is an ordinary word graph (a FSA without cycles  Completeness in this context means: the parse forest grammar contains all possible parses For any threshold it is the case that the intersection problem of off-line parsable DCGs and FSA is decidable Soundness in this context should be understood as the property that all parse trees in the parse forest grammar are valid parse trees From the DCG we take its context-free skeleton Then we compute the intersection of the skeleton with the input FSA This results in a parse forest grammar Finally, we add the corresponding constraints from the DCG to the grammar rules of the parse forest grammar This has the advantage that the result is still sound and complete, although the size of the parse forest grammar is not optimal (as a consequence it is not guaranteed that the parse forest grammar contains a parse tree  In this paper we investigate whether the same techniques can be applied in case the grammar is a constraint-based grammar rather than a CFG For specificity we will take the grammar to be a Definite Clause Grammar (DCG)  The calculation of the intersection of a CFG and a FSA is very simple  The (context-free) grammar defining this intersection is simply constructed by keeping track of the state names in the non-terminal category symbols Thus the intersection of a FSA and a CFG is a CFG that exactly derives all parse-trees Such a grammar might be called the parse-forest grammar Parsing uncertain input might be necessary in case of ill-formed textual input, or in case of speech input In fact the (possibly enormously large) parse forest grammar might define an empty language (if the intersection was empty  Luckily `ordinary' recognizers/parsers for CFG can be easily generalized to construct this intersection yielding (in typical cases) a much smaller grammar To illustrate how a parser can be generalized to accept a FSA as input we present a simple top-down parser A context-free grammar is represented as a definite-clause specification as follows The relation top/1 defines the start symbol The predicate side_effect is used to construct the parse forest grammar For the sentence `a a b b' we obtain the parse forest grammar: The reader easily verifies that indeed this grammar generates (a isomorphism of) the single parse tree of this example, assuming of course that the start symbol for this parse-forest grammar is p(s,0,4  In the parse-forest grammar, complex symbols are non-terminals, atomic symbols are terminals Next consider the definite clause specification of a FSA Thus the following FSA, defining the regular language L aa b i FSA of course generalizes such word lattices If our input `sentence' now is the definition of trans/3 as given above, we obtain the following parse forest grammar (where the start symbol is p(s,q0,q2 Thus, even though we now use the same parser for an infinite set of input sentences (represented by the FSA) the parser still is able to come up with a parse forest grammar A possible derivation for this grammar constructs the following (abbreviated) parse tree in figure  if the intersection is empty we want an empty parse-forest grammar The same techniques that are used for calculating the intersection of a FSA and a CFG can be applied in the case of DCGs As another example, certain techniques to deal with ill-formed input can be characterized as finite state transducers ; the composition of an input string with such a finite state transducer results in a FSA that can then be input for syntactic parsing In order to compute the intersection of a DCG and a FSA we assume that FSA are represented as before A fortiori the problem of deciding whether the intersection of a FSA and a DCG is empty or not is undecidable I now show that the question whether the intersection of a FSA and an off-line parsable DCG is empty is undecidable A yes-no problem is undecidable (cf I use Post's Correspondence Problem (PCP) as a well-known undecidable problem Such techniques might be of use both in the case of written and spoken language input First I give a simple algorithm to encode any instance of a PCP as a pair, consisting of a FSA and an off-line parsable DCG, in such a way that the question whether there is a solution to this PCP is equivalent to the question whether the intersection of this FSA and DCG is empty This FSA generates x  Observe that the DCG is off-line parsable.