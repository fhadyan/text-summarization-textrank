 Developers may wish to add and test further lexical entries without frequently recompiling the rules, and it may also be necessary to deal with unknown words at run time, for example by querying a large external lexical database or attempting spelling correction (Alshawi, 1992, pp124-7 .  These parameters - languages with a complex morphology/syntax interface but a limited number of affix combinations, tasks where the lexicon is not necessarily known at compile time, bidirectional processing, and the need to ease development rather than optimize run-time efficiency - dictate the design of the morphology compiler described in this paper, in which spelling rules and possible affix combinations (items (a) and (b but not the lexicon (item (c are composed in the compilation phase..  Value may be atomic or it may be a boolean expression.. 