 Earley deduction is based on grammars encoded as definite clauses For unit clauses, the priority is identified with the preference value The following is the algorithm for bottom-up best-first Earley deduction The instantiation (prediction) rule of top-down Earley deduction is not needed in bottom-up Earley deduction, because there is no prediction The addition of non-unit clauses should be made dependent on the goal and the base cases in order to go from a purely bottom-up algorithm to a directed algorithm that combines the advantages of top-down and bottom-up processing The set of selected clauses is called the chart The selection of clauses is guided by a scanning step (section ) and indexing of clauses (section  The scanning step selects clauses that can appear as leaves in the proof tree for a given goal G If this is the case, then all the words contained in the PHON value of the goal can have their lexical items selected as unit clauses to start bottom-up processing Base case lookup must be defined specifically for different grammatical theories and directions of processing by the predicate lookup/2, whose first argument is the goal and whose second argument is the selected base case The following clause defines the lookup relation for parsing with HPSG Note that the base case clauses can become further instantiated in this step This avoids combination of items that are not adjacent in the input string In bottom-up Earley deduction, the first step towards proving a goal is perform lookup for the goal, and to add all the resulting (unit) clauses to the chart Also, all non-unit clauses of the program, which can appear as internal nodes in the proof tree of the goal, are added to the chart The scanning step achieves a certain degree of goal-directedness for bottom-up algorithms because only those clauses which can appear as leaves in the proof tree of the goal are added to the chart This is especially important for a bottom-up algorithm which is not goal-directed like top-down processing Without indexing, there are too many combinations of items which are useless for a proof of the goal, in fact there may be infinitely many items so that termination problems can arise For these grammars data-driven bottom-up processing is more appropriate non-directional basic categorial grammars  With the use of indices, the lookup relation becomes a relation between goals and items In order to deal with such goals, we associate the goals in the body of a clause with goal types The goals that are relevant for bottom-up Earley deduction are called waiting goals because they wait until they are activated by a unit clause that unifies with the goal Whenever a unit clause is combined with a non-unit clause all goals up to the first waiting goal of the resulting clause are proved according to their goal type, and then a new clause is added whose selected goal is the first waiting goal In the following inference rule for clauses with mixed goal types, is a (possibly empty) sequence of goals without any waiting goals, and is a (possibly empty) sequence of goals starting with a waiting goal One is that the scanning step may not add all the program clauses to the chart that are needed for proving a goal, and the other is that the indexing may prevent the derivation of a clause that is needed to prove the goal In order to avoid incompleteness, the scanning step must add all program clauses that are needed for a proof of the goal to the chart, and the combination of indices may only fail for inference steps which are useless for a proof of the goal Unit clauses are associated with a numerical preference value, and non-unit clauses with a formula that determines how its preference value is computed from the preference values of the goals in the body of the clause