 Earley deduction is based on grammars encoded as definite clauses The preference values are the basis for giving priorities to items For unit clauses, the priority is identified with the preference value The implementation of best-first search does not combine new items with the chart immediately, but makes use of an agenda , on which new items are ordered in order of descending priority The following is the algorithm for bottom-up best-first Earley deduction The instantiation (prediction) rule of top-down Earley deduction is not needed in bottom-up Earley deduction, because there is no prediction The second problem is that all non-unit clauses of the program are added to the chart The addition of non-unit clauses should be made dependent on the goal and the base cases in order to go from a purely bottom-up algorithm to a directed algorithm that combines the advantages of top-down and bottom-up processing parsing, generation, noisy input, incremental processing etc  In principle, this rule can be applied to any pair of unit clauses and non-unit clauses of the program to derive any consequences of the program The set of selected clauses is called the chart The selection of clauses is guided by a scanning step (section ) and indexing of clauses (section  The scanning step selects clauses that can appear as leaves in the proof tree for a given goal G The base cases must also be instantiated in order to find those that are useful for proving a given goal If this is the case, then all the words contained in the PHON value of the goal can have their lexical items selected as unit clauses to start bottom-up processing Base case lookup must be defined specifically for different grammatical theories and directions of processing by the predicate lookup/2, whose first argument is the goal and whose second argument is the selected base case The following clause defines the lookup relation for parsing with HPSG % lookup Goal BaseCase) lookup(sign(phon:PhonList lexical_sign(phon Word] synsem:X) ) member(Word,PhonList lexicon(Word,X  Note that the base case clauses can become further instantiated in this step This avoids combination of items that are not adjacent in the input string In bottom-up Earley deduction, the first step towards proving a goal is perform lookup for the goal, and to add all the resulting (unit) clauses to the chart Also, all non-unit clauses of the program, which can appear as internal nodes in the proof tree of the goal, are added to the chart The scanning step achieves a certain degree of goal-directedness for bottom-up algorithms because only those clauses which can appear as leaves in the proof tree of the goal are added to the chart However, the string positions are useful as an indexing of the items so that it can be easily detected whether their combination can contribute to a proof of the goal This is especially important for a bottom-up algorithm which is not goal-directed like top-down processing Without indexing, there are too many combinations of items which are useless for a proof of the goal, in fact there may be infinitely many items so that termination problems can arise We generalize the indexing scheme from chart parsing in order to allow different operations for the combination of strings Indexing improves efficiency by detecting combinations that would fail anyway and by avoiding combinations of items that are useless for a proof of the goal For these grammars data-driven bottom-up processing is more appropriate Non-adjacent combination: This indexing scheme is useful for order-monotonic grammars non-directional basic categorial grammars  Free combination: Allows an item to be used several times in a proof, for example for the non-unit clauses of the program, which would be represented as items of the form  With the use of indices, the lookup relation becomes a relation between goals and items In order to deal with such goals, we associate the goals in the body of a clause with goal types The goals that are relevant for bottom-up Earley deduction are called waiting goals because they wait until they are activated by a unit clause that unifies with the goal Whenever a unit clause is combined with a non-unit clause all goals up to the first waiting goal of the resulting clause are proved according to their goal type, and then a new clause is added whose selected goal is the first waiting goal In the following inference rule for clauses with mixed goal types, is a (possibly empty) sequence of goals without any waiting goals, and is a (possibly empty) sequence of goals starting with a waiting goal The other goal types are also proved by resolution One is that the scanning step may not add all the program clauses to the chart that are needed for proving a goal, and the other is that the indexing may prevent the derivation of a clause that is needed to prove the goal In order to avoid incompleteness, the scanning step must add all program clauses that are needed for a proof of the goal to the chart, and the combination of indices may only fail for inference steps which are useless for a proof of the goal In order to keep the search space small (and finite to ensure termination) the scanning step should (ideally) add only those items that are needed for proving the goal to the chart, and the indexing should be chosen in such a way that it excludes derived items that are useless for a proof of the goal Unit clauses are associated with a numerical preference value, and non-unit clauses with a formula that determines how its preference value is computed from the preference values of the goals in the body of the clause