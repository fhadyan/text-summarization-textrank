 Matching: Select all rules carrying the current category Execute the tests for each of these rules on the input structure and add those passing their test to the conflict set Conflict resolution: Select an element from the conflict set Any alternative is based on backtracking at least one rule Backtrack points correspond to conflict sets containing more than one element Backtracking may turn out to be inefficient if it involves recomputation of previously generated substrings This is possible due to the design properties of TGL: rules cannot irrevocably influence other parts of the solution In particular, the context-free backbone implicit in any solution and the restrictions to side effects mentioned above keep the structural effects of TGL rules local Let us call the sequence of strings generated by previous actions its pre-context, the set of string sequences generated from the elements of the conflict set its ego, and the sequence of strings generated from subsequent actions its post-context Both possibilities taken together allow a system that feeds TG/2 to specify linguistic criteria of preferred solutions to be generated first In particular, TG/2 can be smoothly integrated with 'deep' generation processes, integrates canned text, templates, and context-free rules into a single formalism, allows for both textual and tabular output, efficiently reuses generated substrings for additional solutions, and can be parameterized according to linguistic properties (regarding style, grammar, fine-grained rhetorics etc  The criteria are defined in terms of rule names, and a criterion is fulfilled if some corresponding rule is successfully applied We call such a rule c-rule TG/2 implements a simple strategy that processes those backtrack points first that have conflict sets containing c-rules, and preferrably choses a c-rule from a conflict set When applied incrementally, this procedure yields all solutions fulfilling (some of) the criteria first It would be desirable to see the solution fulfilling most criteria first Any c-rule chosen may be the last one in a derivation, whereas chosing a non-c-rule may open up further opportunities of chosing c-rules Analyzing dependencies of criteria: The solution fulfilling most criteria is generated first if sets of mutually independent criteria are applied: fulfilling one criterion must not exclude the applicability of another one, unless two criteria correspond to rules of the same conflict set If these conditions are met, chosing a c-rule from every conflict set, if possible, will lead to a globally best solution first Learning dependencies of criteria: Missing look-ahead information could be acquired automatically by exploiting the derivational history of previously generated texts For every applied rule, the set of c-rules applied later in the current subtree of a derivation is stored Computing such information from the context-free backbone of TGL grammars instead would be less effective since it neglects the drastic filtering effects of preconditions However, different GIL structures may, for a TGL rule, lead to different sets of follow-up c-rules informal wordings The rules are encoded in TGL, a language that allows the definition of canned text items, templates, and context-free rules within the same formalism TGL rules can, and should, be written with generation in mind, i In particular, side effects could modify the data base in such a way that other rules become applicable [  On the other hand, TGL sublanguage grammars can be developed using existing resources For instance, suitable fragments of context-free grammars translated into TGL could be augmented by the domain and task specific properties needed TG/2 is being used in the domain of appointment scheduling within DFKI's COSMA system By constraining the effects of production rules in such a way, the disadvantages of early production systems are avoided A production rule may involve a direct mapping to surface forms (canned text require to fill in some missing portion from a surface text (template or induce the application of other rules (classical grammar rules) Early template-based generation methods have correctly been criticized for beeing too inflexible to account adequately for the communicative and rhetorical demands of many applications On the other hand, templates have been successfully used when these demands could be hard-wired into the rules In Section the formalism TGL (Template Generation Language) for production rules is introduced The properties of TGL allow for efficient generation of all possible solutions in any order It is used to parameterize TG/2 by inducing an order in which the solutions are generated (Section  TG/2 has an internal language, GIL, that corresponds to an extended predicate argument structure Any input to TG/2 is first translated into GIL before being processed GIL is designed to be a target language suited for deep generation processes TGL defines a general format for expressing production rules as precondition-action pairs (cf Figure  A TGL rule is applicable if its preconditions are met A TGL rule is successfully applied, if the action part has been executed without failure Failure to apply a TGL rule signals that the rule does not cover the portion of the input structure submitted to it Figure shows a sample TGL rule Given the input GIL structure of Figure , the VP Sie am Freitag treffen [to meet you on Friday] could be generated from this rule Among the optional constituents, only the temporal adjunct would find appropriate material in the GIL input structure (under THEMETIME-ADJ  Every TGL rule has a unique name, denoted by the initial string This name is used for expressing preferences on alternative rules (cf Section  Correspondingly, categories are used for rule selection (see below  They ensure that a set of TGL rules possesses a context-free backbone Template: Actions under :TEMPLATE include the selection of other rules RULE, :OPTRULE executing a function FUN or returning an ASCII string as a (partial) result When selecting other rules by virtue of a category, a Lisp function is called that identifies the relevant portion of the input structure for which a candidate rule must pass its associated tests Functions must return an ASCII string Using TGL, small task- and domain-specific grammars can be written quickly Larger grammars may become difficult to maintain unless special care is taken by the grammar writer to preserve a global structure of rules, both by defining suitable categories and by documenting the rules TGL rules are presently written using a text editor A specialized TGL grammar editor could improve the development and the organization of grammars considerably