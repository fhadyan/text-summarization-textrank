 Consequently, it is possible to have conflicting defaults and multiple w-explanations for a nonmonotonic sort Another option would be to interpret fail as if the application of the nonmonotonic rule should not be allowed This makes it important to allow fail to be the result of applying a nonmonotonic rule This is done by defining a nonmonotonic rule default for the class value, which is assumed to be the most general class in a defined hierarchy The second is that the nonmonotonic unification operation used is order independent This default rule can be used when defining verbs While retrieving the information for these two verbs we will obtain the following two feature structures containing nonmonotonic sorts: Since I have used immediate for the when-slot in the definition of the default rule, this nonmonotonic rule will be applied immediately after retrieving all information about a verb in the hierarchy The definition of value constraints as a nonmonotonic rule makes use of negation, interpreted as negation as failure The next nonmonotonic structure I want to discuss is any-values The last nonmonotonic operations I want to discuss are completeness and coherence as used in LFG I will, instead, make use of the two nonmonotonic definitions below Compared with Reiter's default logic, our notion of nonmonotonic sorts corresponds to default theories Unification of nonmonotonic sorts would then correspond to merging two default theories into one single theory and our notion of explaining a nonmonotonic sort corresponds to computing the extension of a default theory in default logic The restriction in our nonmonotonic rules that is similar to the restriction into normal default rules and captures the important property, that the application of one nonmonotonic rule should not affect the applicability of previously applied rules The decidability of the nonmonotonic rules defined here is, however, highly dependant on the given subsumption order As mentioned previously there is with nonmonotonic sorts, as well as normal default logic, a possibility of conflicting defaults and thus multiple nonmonotonic extensions for a structure One difference is that nonmonotonic sorts allow that the application of a nonmonotonic rule leads to fail, i However, since fail is allowed as a valid explanation for a nonmonotonic sort, there is, as for normal default logic, always at least one explanation for a sort The two following examples will illustrate the difference between nonmonotonic rules giving multiple extensions and nonmonotonic rules giving a single explanation fail Note that even though there is an order dependency on the application order of nonmonotonic rules this does not affect the order independency on nonmonotonic unification between application of nonmonotonic rules First, it is possible to generalize these definitions to allow the first component of a nonmonotonic sort to contain substructures that are also nonmonotonic sorts Therefore the order on which nonmonotonic rules at different substructures are applied is important and all possible application orders must be considered Considering unification of nonmonotonic sorts it is not necessary to simplify the nonmonotonic part of the resulting sort As stated previously, nonmonotonic sorts allow multiple explanations of a nonmonotonic sort One further example will illustrate that it is also possible to define negation as failure with nonmonotonic rules However, if this definition is to be really useful we must also allow one definition of a nonmonotonic rule to make use of other nonmonotonic rules In our original definition we said that the nonmonotonic rule above should be applied if  This was done by generalizing the work on nonmonotonic sorts to allow not only normal defaults rules but general default rules that are defined by the user One such class of constructions is those that have some degree of nonmonotonic behaviour It is, however, very useful when defining nonmonotonic constructions These requirements can be both structures in the subsumption order and nonmonotonic rules In Reiter's default logic this is expressed with the following normal default rule In this paper I want to allow the user to use other forms of nonmonotonic inferences and not only the normal default rule given above In the syntax given above name assigns a name to the defined rule, and thus allows the user to use nonmonotonic information when defining linguistic knowledge This paper describes a method that permits the user to define such nonmonotonic constructions Note that although the when slot in the definition of a nonmonotonic rule allows the user to define when his rule is going to be applied we will still have an order independent nonmonotonic unification operator In this section I provide give the formal definitions for nonmonotonic sorts and how nonmonotonic sorts are unified and explained A nonmonotonic sort is a structure containing both information from the basic subsumption order and information about default rules to be explained at a later point in the computation Definition 1 A nonmonotonic sort is a pair where and is a set of nonmonotonic rules of the form where w is an atom and , and  It is assumed that for each nonmonotonic rule , , , and  This is done through generalizing the work on nonmonotonic sorts  As seen by the definition a nonmonotonic sort is considered to be a pair of monotonic information from the subsumption order and nonmonotonic information represented as a set of nonmonotonic rules The user can assign nonmonotonic information to a nonmonotonic sort by calling a nonmonotonic definition as defined in the previous section The actual nonmonotonic rule occurring within the sort is a pair consisting of the when slot and the last part of the nonmonotonic definition, with the parameter variables instantiated according to the call made by the user The second part of this definition contains some well-foundedness conditions for a nonmonotonic sort This restriction ensures that the application of one default rule will never cause previously applied default rules to be inapplicable The next two conditions in the definition, and , guarantee that the default rule is or can be applicable to the nonmonotonic sort The last condition on a nonmonotonic sort, , may seem superfluous Note in particular that the above conditions on a nonmonotonic sort implies that may be fail Given the unification operation of objects within the subsumption order and the definition of nonmonotonic sorts it is possible to define an operation for nonmonotonic unification Definition 2 The nonmonotonic unification ( ) of two nonmonotonic sorts and is the sort where and The nonmonotonic unification is computed by computing the unification of the monotonic parts of the two sorts and then taking the union of their nonmonotonic parts The extra conditions used when forming the union of the nonmonotonic parts of the sorts are the same as in the definition of a nonmonotonic sort and their purpose is to remove nonmonotonic rules that are no longer applicable, or would have no effect when applied to the sort resulting from the unification When using nonmonotonic sorts containing nonmonotonic rules, we also need to know how to merge the monotonic and nonmonotonic information within the sort I will use the terminology w-application for applying one nonmonotonic rule to the sort and w-explanation when applying all possible rules This means that only nonmonotonic rules whose first component is ware considered and that it is possible to choose which nonmonotonic rules should be applied in a particular point at some computation In addition note that the restriction that in all nonmonotonic rules and the special cases for ensures that the application of one nonmonotonic rule never destroys the applicability of a previously applied rule Since the definition of w-applicability and the condition that in all nonmonotonic rules ensures that whenever a nonmonotonic rule is applied it can never be inapplicable, there is no need to check if the preconditions of earlier applied nonmonotonic rules still hold