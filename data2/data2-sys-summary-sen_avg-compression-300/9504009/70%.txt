 Typed feature structures (TFSs) serve as a means for the specification of linguistic information in current linguistic formalisms such as HPSG ( , ) or Categorial Grammar (  Generalizing first-order terms (FOTs TFSs are also used to specify logic programs and constraint systems in LOGIN ( LIFE ( ALE ( , TFS ( ) and others One cell is required for every node and arc, so for representing a graph of n nodes and m arcs, n+m cells are needed As an example, figure depicts a possible heap representation of the TFS b(b(1d,1 d  Before processing a TFS, its linear representation is transformed to a set of equations each having a flat (nesting free) format To facilitate this a set of registers that store addresses of TFSs in memory is used Figure depicts examples of the equations corresponding to two TFSs When processing an equation of the form representing part of a query, two different instructions are generated Then, for every argument Xij, an instruction of the form put_arc Xi0, j, Xij is generated put_arc fills this space with REF cells Since only put_node sets the registers, all put_node instructions must be executed before any put_arc instruction is Hence, the machine maintains two separate streams of instructions, one for put_node and one for put_arc, and executes the first completely before moving to the other When this code is executed (first the put_node instructions, then the put_arc ones the resulting representation of the TFS in memory is the one shown above in figure  One of the reasons for the efficiency of our compiler is that it performs an important part of the unification during compile-time: the type unification Since type unification adds information by returning the features of the unified type, this operation builds new structures, in our design, that reflect the added knowledge When the type hierarchy is processed, the (full) subsumption relation is computed Then, a table is generated which stores, for every two types t1,t2, the least upper bound  Out of this table a series of abstract machine language functions are generated Each such function receives one parameter, the address of a TFS on the heap When executed, it builds on the heap a skeleton for the unification result: an STR cell of the type , and a REF cell for each appropriate feature of it Consider unify_type[t1,t2 addr) where addr is the address of a TFS A (of type t2) in memory As an example, we list below (figure ) the resulting code for the unification the two types a and b Three kinds of machine instructions are generated when processing a program equation of the form Xi0 = t(Xi1 Xin  For example, the machine code that results from compiling the program a(3d1,3) is depicted in figure  The get_structure instruction is generated for a TFS Ap (of type t) which is associated with a register Xi Since Aq might have undergone some type inference or previous binding (for example, due to previous unifications caused by other instructions the value of Xi must first be dereferenced The dereferenced value of Xi, addr, can either be a self-referential REF cell or an STR cell In the first case, the TFS has to be built by the program A new TFS is being built on top of the heap (using code similar to that of put_structure) with addr set to point to it The second case, in which Xipoints to an existing TFS of type t is the more interesting one An existing TFS has to be unified with a new one whose type is t In contrast to the latter, the two TFS arguments of unify are in memory, and full unification is performed When a sequence of instructions that were generated for some TFS is successfully executed on some query, the result of the unification of both structures is built on the heap and every register Xi stores the value of its corresponding node in this graph One of the drawbacks of maintaining total structures is that when two TFSs are unified, the values of features that are introduced by the unified type have to be built For example, unify_type[a,b] (figure ) has to build a TFS of type bot, which is the value of the f4 feature of type c A VAR cell whose contents is a type t stands for the most general TFS of type t This function (which is automatically generated by the type hierarchy compiler) builds a TFS of the designated type on the heap, with VAR cells instead of REF cells for the features The previous section delineated a very simple abstract machine, capable of unifying two simple TFSs We now add to this machine control structures that will enable parsing The abstract machine is composed of data structures and a set of instructions, augmented by a compiler from the TFS formalism to the abstract instructions A grammar is a finite set of rules together with a start feature structure As Moreover, the LIFE machine is limited to term unification, whereas our machine includes a control module that enables manipulation of whole grammars The same code is generated for the queries, with additional advance instructions preceding each TFS of the query The abstract machine ensures that a grammars specified using our system are endowed with well defined meaning The syntax of programs is extended, too, from a TFS to a single MRS Again, the same code is generated for the TFSs of a program: program-code for each element of the rule's body and query-code for the head Before the first TFS, a start_rule instruction is generated A move_dot and next_item instructions are generated between two consecutive structures, and after the last one, the head, an end_rule instruction concludes the generated code To understand the effect of these instructions, one must understand the non-uniform internal representation of dotted rules A complete edge is represented as a single TFS, its head, since the rest of the structures (that are unaccessible from the head) are irrelevant Since the rules are applied incrementally, a TFS at a time, care must be taken of reentrancies The rules manipulate registers which must contain the right values when used move_dot is executed after the successful unification of one TFS; it copies the newly created edge, including the values of the registers, to the chart (and interacts with the agenda  (DFS  The order the chart is searched for active edges is right to left: from (i,i) to (0,i  Determining the values of these parameters is program-independent: the maintenance of the chart is fixed For lack of space we don't detail the control module As linguistic formalisms become more rigorous, the necessity of well defined semantics for grammar specifications increases In addition, we described a compiler for a general TFS-based language The compiled code, in terms of abstract machine instructions, can be interpreted and executed on ordinary hardware The use of abstract machine techniques is expected to result in highly efficient processing Section describes the abstract machine core design along with the compilation scheme In section control structures are added to enable parsing An HPSG grammar consists of a type specification and grammar rules (including principles and lexical rules  The basic entity of HPSG is the (typed) feature structure (TFS which is a connected, directed, labeled, possibly cyclic, finite graph, whose nodes are decorated with types and whose edges are labeled by features A TFS is reentrant if it contains two different paths that lead to the same node The set of types includes both , the least type, and , the greatest one Linguistic formalisms (in particular, HPSG) use TFSs as the basic blocks for representing linguistic data: lexical items, phrases and rules Hence, is the most general type, subsuming every other, and is the contradictory type, subsumed by every other The inheritance hierarchy is required to be bounded complete: every set of consistent types must have a unique least upper bound  Every partial order can be naturally extended to a bounded complete one The basic operation performed on TFSs is unification (  There are various definitions for TFS unification, and we base our unification algorithm on the definition given in  Two TFSs A and B are inconsistent if their unification results in failure, denoted by  Usually, no mechanism for manipulating TFSs (e A program (or a grammar) contains a type specification, consisting of a type hierarchy and an appropriateness specificatione they are not appropriate for any type t'such that  Each type (except and ) must be characterized by exactly one statement The arity of a type t, Ar(t is the number of features appropriate for it We use the type hierarchy in figure as a running example, where bot stands for  The type is systematically omitted from type specifications Assuming that the feature names are ordered alphabetically, the linear representation of an example TFS is given in figure  First, TFSs are typed, as opposed to (ordinary) FOTs TFSs are interpreted over more specific domains than FOTs In addition, TFSs label the arcs by feature names, whereas FOTs use a positional encoding for argument structure The machine's engine is designed for unifying two TFSs: a program and a query The program is compiled once to produce machine instructions Processing a query builds a graph representation of the query in the machine's memory The result of the unification is a new TFS, represented as a graph in the machine's memory In what follows we interleave the description of the machine, the TFS language it is designed for and the compilation of programs in this language Following the WAM, we use a global, one-dimensional array called HEAP of data cells Data cells are tagged: STR cells correspond to nodes, and store their types, while REF cells represent arcs, and contain the address of their targets The number of arcs leaving a node of type t is Ar(t fixed due to total well-typedness Given a type t and a feature f, the position of the arc corresponding to f (f-arc) in any TFS of type t can be statically determined; the subgraph that is the value of f can be accessed in one step