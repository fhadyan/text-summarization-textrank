 put_arc fills this space with REF cells Since type unification adds information by returning the features of the unified type, this operation builds new structures, in our design, that reflect the added knowledge An existing TFS has to be unified with a new one whose type is t For example, unify_type[a,b] (figure ) has to build a TFS of type bot, which is the value of the f4 feature of type c A VAR cell whose contents is a type t stands for the most general TFS of type t This function (which is automatically generated by the type hierarchy compiler) builds a TFS of the designated type on the heap, with VAR cells instead of REF cells for the features The previous section delineated a very simple abstract machine, capable of unifying two simple TFSs The abstract machine is composed of data structures and a set of instructions, augmented by a compiler from the TFS formalism to the abstract instructions Before the first TFS, a start_rule instruction is generated (DFS  Determining the values of these parameters is program-independent: the maintenance of the chart is fixed For lack of space we don't detail the control module In addition, we described a compiler for a general TFS-based language The use of abstract machine techniques is expected to result in highly efficient processing An HPSG grammar consists of a type specification and grammar rules (including principles and lexical rules  A program (or a grammar) contains a type specification, consisting of a type hierarchy and an appropriateness specification Each type (except and ) must be characterized by exactly one statement The type is systematically omitted from type specifications The program is compiled once to produce machine instructions