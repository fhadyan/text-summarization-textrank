 As an example, figure depicts a possible heap representation of the TFS b(b(1d,1 d  Figure depicts examples of the equations corresponding to two TFSs When processing an equation of the form representing part of a query, two different instructions are generated put_arc fills this space with REF cells Hence, the machine maintains two separate streams of instructions, one for put_node and one for put_arc, and executes the first completely before moving to the other When this code is executed (first the put_node instructions, then the put_arc ones the resulting representation of the TFS in memory is the one shown above in figure  One of the reasons for the efficiency of our compiler is that it performs an important part of the unification during compile-time: the type unification Since type unification adds information by returning the features of the unified type, this operation builds new structures, in our design, that reflect the added knowledge When the type hierarchy is processed, the (full) subsumption relation is computed Out of this table a series of abstract machine language functions are generated Each such function receives one parameter, the address of a TFS on the heap When executed, it builds on the heap a skeleton for the unification result: an STR cell of the type , and a REF cell for each appropriate feature of it Consider unify_type[t1,t2 addr) where addr is the address of a TFS A (of type t2) in memory Three kinds of machine instructions are generated when processing a program equation of the form Xi0 = t(Xi1 Xin  The get_structure instruction is generated for a TFS Ap (of type t) which is associated with a register Xi In the first case, the TFS has to be built by the program The second case, in which Xipoints to an existing TFS of type t is the more interesting one An existing TFS has to be unified with a new one whose type is t In contrast to the latter, the two TFS arguments of unify are in memory, and full unification is performed When a sequence of instructions that were generated for some TFS is successfully executed on some query, the result of the unification of both structures is built on the heap and every register Xi stores the value of its corresponding node in this graph One of the drawbacks of maintaining total structures is that when two TFSs are unified, the values of features that are introduced by the unified type have to be built For example, unify_type[a,b] (figure ) has to build a TFS of type bot, which is the value of the f4 feature of type c A VAR cell whose contents is a type t stands for the most general TFS of type t This function (which is automatically generated by the type hierarchy compiler) builds a TFS of the designated type on the heap, with VAR cells instead of REF cells for the features The previous section delineated a very simple abstract machine, capable of unifying two simple TFSs We now add to this machine control structures that will enable parsing The abstract machine is composed of data structures and a set of instructions, augmented by a compiler from the TFS formalism to the abstract instructions Moreover, the LIFE machine is limited to term unification, whereas our machine includes a control module that enables manipulation of whole grammars The same code is generated for the queries, with additional advance instructions preceding each TFS of the query The abstract machine ensures that a grammars specified using our system are endowed with well defined meaning Before the first TFS, a start_rule instruction is generated A move_dot and next_item instructions are generated between two consecutive structures, and after the last one, the head, an end_rule instruction concludes the generated code To understand the effect of these instructions, one must understand the non-uniform internal representation of dotted rules A complete edge is represented as a single TFS, its head, since the rest of the structures (that are unaccessible from the head) are irrelevant The rules manipulate registers which must contain the right values when used move_dot is executed after the successful unification of one TFS; it copies the newly created edge, including the values of the registers, to the chart (and interacts with the agenda  (DFS  Determining the values of these parameters is program-independent: the maintenance of the chart is fixed For lack of space we don't detail the control module In addition, we described a compiler for a general TFS-based language The use of abstract machine techniques is expected to result in highly efficient processing Section describes the abstract machine core design along with the compilation scheme An HPSG grammar consists of a type specification and grammar rules (including principles and lexical rules  The basic entity of HPSG is the (typed) feature structure (TFS which is a connected, directed, labeled, possibly cyclic, finite graph, whose nodes are decorated with types and whose edges are labeled by features A TFS is reentrant if it contains two different paths that lead to the same node The set of types includes both , the least type, and , the greatest one Linguistic formalisms (in particular, HPSG) use TFSs as the basic blocks for representing linguistic data: lexical items, phrases and rules Hence, is the most general type, subsuming every other, and is the contradictory type, subsumed by every other Every partial order can be naturally extended to a bounded complete one The basic operation performed on TFSs is unification (  There are various definitions for TFS unification, and we base our unification algorithm on the definition given in  Two TFSs A and B are inconsistent if their unification results in failure, denoted by  A program (or a grammar) contains a type specification, consisting of a type hierarchy and an appropriateness specification Each type (except and ) must be characterized by exactly one statement The arity of a type t, Ar(t is the number of features appropriate for it The type is systematically omitted from type specifications Assuming that the feature names are ordered alphabetically, the linear representation of an example TFS is given in figure  First, TFSs are typed, as opposed to (ordinary) FOTs In addition, TFSs label the arcs by feature names, whereas FOTs use a positional encoding for argument structure The machine's engine is designed for unifying two TFSs: a program and a query The program is compiled once to produce machine instructions The result of the unification is a new TFS, represented as a graph in the machine's memory Given a type t and a feature f, the position of the arc corresponding to f (f-arc) in any TFS of type t can be statically determined; the subgraph that is the value of f can be accessed in one step