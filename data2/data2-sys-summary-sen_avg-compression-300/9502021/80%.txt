 Unification-based grammar formalisms can be viewed as generalizations of Context-Free Grammars (CFG) where the nonterminal symbols are replaced by an infinite domain of feature structures Consider Figure  Tree (a) shows a LIG derivation of the substring from the object  In this case, the value of the feature fin must be a, whereas, the feature g is not fixed Furthermore, the value of the feature g in must be b, whereas, the feature f is not fixed Note that in this tree the value of the feature g in is and the value of the feature f in is Suppose that, in addition to the tree shown in Figure the grammar generates the pair of trees shown in Figure  The context-freeness of plpatr means that given the three trees shown in Figures and the tree shown in Figure will also be generated by the grammar This gives us a means of efficiently storing the potentially unbounded feature structures associated with nodes in a derivation tree (derived feature structures  This entry would be underspecified, for example, the value of feature would be specified to be any feature stored in the array entry for the substring whose feature fhad the value a The plpatr recognition algorithm employs a second array (called the compatibility array which encodes information about the compatibility of derived feature structures Tuples of compatible derived feature structures are stored in the compatibility array using exactly the same approach used to store feature structures in the main recognition array Our goal is to generalize the constraints inherent in LIG, to a formalism that manipulates feature structures rather than stacks As a guiding heuristic we will avoid formalisms that generate tree sets with an unbounded number of unbounded, dependent branches In naive implementations of unification grammar parsers, feature structures play the same role as nonterminals in standard context-free grammar parsers Productions now specify how the tree associated with the mother is related to the trees associated with the daughters Under these conditions, the tree set shown in Figure can be generated z) subtrees (these subtrees must be the full binary tree  We require that subtrees of the mother that are passed to daughters that share subtrees with one another must appear as siblings in the mother's tree As a further illustration of the constraints places on shared subtrees, Figure shows a local tree that could appear in a derivation tree Finally, we note that acyclic feature structures without re-entrancy can be viewed as trees with branches labelled by feature names and atomic values only found at leaf nodes (interior nodes being unlabelled  Having made the move from trees to feature structures, we consider the possibility of re-entrancy in plpatr Note that the feature structure at the root of a plpatr derivation tree will not involve re-entrancy In unification-based grammar, the feature structure associated with the root of the tree is often regarded as the structure that has been derived from the input (i To do this, unbounded feature information is passed up the tree in a way that violates the constraints developed in this paper Because feature structures associated with all nodes in the tree are available, feature information need only be passed up the tree when it is required in order to establish dependencies within the derivation tree Furthermore, re-entrancy in the form of shared feature structures within and across nodes will be found in plpatr (see for example Figure  LIG are more powerful than cfg and are known to be weakly equivalent to Tree Adjoining Grammar, Combinatory Categorial Grammar, and Head Grammar  As is the case for the tree sets of ig, LIG and Tree Adjoining Grammar, the tree sets generated by pltg have path sets that are context-free languages While the tree sets of LIG and Tree Adjoining Grammars have independent branches, pltg tree sets exhibit dependent branches, where the number of dependent branches in any tree is bounded by the grammar Note that the number of dependent branches in the tree sets of ig is not bounded by the grammar (e